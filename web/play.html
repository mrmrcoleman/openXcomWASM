<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Play OpenXcom</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ‘½</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --green: #00ff41;
      --green-dim: #00aa2a;
      --green-bg: rgba(0,255,65,0.06);
      --dark: #0a0a0a;
      --card: #111;
      --border: #222;
      --text: #ccc;
      --text-dim: #888;
      --mono: 'Share Tech Mono', monospace;
      --sans: 'Inter', system-ui, sans-serif;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; background: #000; overflow: hidden; font-family: var(--sans); }

    /* ---- Game canvas (hidden until the game starts) ---- */
    #canvas {
      display: none;
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      cursor: none;
    }

    /* ---- Status bar ---- */
    #status {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: var(--green);
      font-family: var(--mono);
      font-size: 14px;
      z-index: 10;
    }

    /* ---- Upload screen ---- */
    #upload-screen {
      display: none;
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: var(--dark);
      color: var(--text);
      z-index: 20;
      overflow-y: auto;
    }
    /* Scanline overlay on upload screen */
    #upload-screen::after {
      content: '';
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: repeating-linear-gradient(
        0deg, transparent, transparent 2px,
        rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px
      );
      pointer-events: none;
      z-index: 100;
    }
    #upload-screen .inner {
      max-width: 640px;
      margin: 0 auto;
      padding: 60px 20px 40px;
      min-height: calc(100vh - 80px);
    }
    #upload-screen .back-link {
      display: inline-block;
      margin-bottom: 32px;
      font-family: var(--mono);
      font-size: 13px;
      color: var(--green-dim);
      text-decoration: none;
      transition: color 0.2s;
    }
    #upload-screen .back-link:hover { color: var(--green); }
    #upload-screen .back-link::before { content: '< '; }
    #upload-screen h1 {
      color: var(--green);
      font-family: var(--mono);
      font-size: clamp(28px, 5vw, 36px);
      margin-bottom: 6px;
      letter-spacing: 2px;
      text-shadow: 0 0 30px rgba(0,255,65,0.3);
    }
    #upload-screen h2 {
      color: var(--green-dim);
      font-family: var(--mono);
      font-size: 16px;
      font-weight: normal;
      margin-bottom: 28px;
    }
    #upload-screen p {
      line-height: 1.7;
      margin-bottom: 16px;
      font-size: 15px;
    }
    #upload-screen a { color: var(--green); }
    #upload-screen a:hover { color: #fff; }
    #upload-screen .note {
      color: var(--text-dim);
      font-size: 13px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px 20px;
      line-height: 1.8;
    }
    #upload-screen .note strong {
      color: var(--text);
      font-size: 13px;
    }
    #upload-screen .note code {
      background: rgba(0,255,65,0.1);
      color: var(--green);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: var(--mono);
      font-size: 12px;
    }
    #drop-zone {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 48px 20px;
      text-align: center;
      margin: 28px 0;
      transition: border-color 0.2s, background 0.2s;
      cursor: pointer;
      background: var(--card);
    }
    #drop-zone:hover {
      border-color: var(--green-dim);
    }
    #drop-zone.drag-over {
      border-color: var(--green);
      background: var(--green-bg);
    }
    #drop-zone .icon { font-size: 48px; margin-bottom: 12px; }
    #drop-zone .label { font-size: 16px; color: var(--text); font-family: var(--sans); }
    #drop-zone .sublabel { font-size: 13px; color: var(--text-dim); margin-top: 8px; }
    #file-input { display: none; }
    #upload-btn {
      display: none;
      margin: 16px auto;
      padding: 14px 40px;
      background: var(--green);
      color: #000;
      font-family: var(--mono);
      font-size: 16px;
      font-weight: bold;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      letter-spacing: 1px;
      transition: transform 0.15s, box-shadow 0.15s;
      box-shadow: 0 0 20px rgba(0,255,65,0.3);
    }
    #upload-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 40px rgba(0,255,65,0.5);
    }
    #file-list {
      margin: 12px 0;
      font-family: var(--mono);
      font-size: 13px;
      color: var(--text-dim);
      max-height: 160px;
      overflow-y: auto;
    }
    #upload-progress {
      display: none;
      margin: 16px 0;
      font-family: var(--mono);
      color: var(--green);
    }
    /* Upload screen footer */
    #upload-footer {
      border-top: 1px solid var(--border);
      padding: 24px 20px;
      text-align: center;
      color: var(--text-dim);
      font-size: 13px;
      line-height: 1.8;
    }
    #upload-footer a { color: var(--green-dim); text-decoration: none; }
    #upload-footer a:hover { color: var(--green); }

    /* ---- Error / diagnostic overlay ---- */
    #error-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.92);
      z-index: 50;
      overflow-y: auto;
      color: var(--text);
      font-family: var(--sans);
    }
    #error-overlay .error-inner {
      max-width: 600px;
      margin: 60px auto;
      padding: 0 20px;
    }
    #error-overlay h2 {
      font-family: var(--mono);
      color: #f55;
      font-size: 22px;
      margin-bottom: 16px;
      letter-spacing: 1px;
    }
    #error-overlay h2::before { content: '! '; }
    #error-overlay p {
      line-height: 1.7;
      margin-bottom: 16px;
      font-size: 15px;
    }
    #error-overlay .error-detail {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 16px;
      font-family: var(--mono);
      font-size: 13px;
      color: #f88;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 20px;
    }
    #error-overlay .error-log {
      background: #111;
      border: 1px solid #222;
      border-radius: 8px;
      padding: 16px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text-dim);
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 20px;
    }
    #error-overlay .error-log .log-ok { color: var(--green); }
    #error-overlay .error-log .log-warn { color: #fa0; }
    #error-overlay .error-log .log-fail { color: #f55; }
    #error-overlay .error-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    #error-overlay .error-actions button,
    #error-overlay .error-actions a {
      padding: 10px 24px;
      border-radius: 6px;
      font-size: 14px;
      font-family: var(--mono);
      cursor: pointer;
      text-decoration: none;
      border: none;
    }
    #error-overlay .btn-retry { background: var(--green); color: #000; font-weight: bold; }
    #error-overlay .btn-retry:hover { background: #00ff55; }
    #error-overlay .btn-reset-err { background: #333; color: var(--text); }
    #error-overlay .btn-reset-err:hover { background: #444; }

    /* ---- Toolbar (visible during gameplay) ---- */
    #toolbar {
      display: none;
      position: fixed;
      top: 8px; right: 8px;
      z-index: 30;
    }
    #toolbar-toggle {
      width: 36px; height: 36px;
      background: rgba(30,30,30,0.8);
      border: 1px solid #444;
      border-radius: 6px;
      color: #aaa;
      font-size: 20px;
      cursor: pointer;
      line-height: 34px;
      text-align: center;
    }
    #toolbar-toggle:hover { background: rgba(60,60,60,0.9); color: #fff; }
    #toolbar-menu {
      display: none;
      margin-top: 4px;
      background: rgba(20,20,20,0.95);
      border: 1px solid #444;
      border-radius: 8px;
      padding: 6px 0;
      min-width: 180px;
    }
    #toolbar-menu button {
      display: block;
      width: 100%;
      padding: 8px 16px;
      background: none;
      border: none;
      color: #ccc;
      font-size: 14px;
      text-align: left;
      cursor: pointer;
      font-family: sans-serif;
    }
    #toolbar-menu button:hover { background: rgba(255,255,255,0.1); color: #fff; }
    #toolbar-menu .danger { color: #f55; }
    #toolbar-menu .danger:hover { background: rgba(255,50,50,0.15); }
    #toolbar-menu .sep { height: 1px; background: #333; margin: 4px 0; }

    /* ---- Modal overlay for import/confirm ---- */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 40;
      justify-content: center;
      align-items: center;
    }
    .modal-overlay.active { display: flex; }
    .modal-box {
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 10px;
      padding: 24px 28px;
      max-width: 420px;
      width: 90%;
      color: #ccc;
    }
    .modal-box h3 { color: #fff; margin-bottom: 12px; font-size: 18px; }
    .modal-box p { margin-bottom: 16px; line-height: 1.5; font-size: 14px; }
    .modal-box .btn-row { display: flex; gap: 10px; justify-content: flex-end; }
    .modal-box button {
      padding: 8px 20px;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
    }
    .modal-box .btn-cancel { background: #333; color: #ccc; }
    .modal-box .btn-cancel:hover { background: #444; }
    .modal-box .btn-confirm { background: #0a0; color: #000; font-weight: bold; }
    .modal-box .btn-confirm:hover { background: #0c0; }
    .modal-box .btn-danger { background: #c22; color: #fff; font-weight: bold; }
    .modal-box .btn-danger:hover { background: #e33; }
    .modal-box .modal-status {
      font-family: monospace;
      font-size: 13px;
      color: #0f0;
      margin-top: 12px;
    }
    #import-file-input { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
  <div id="status">Loading engine...</div>

  <!-- Upload screen shown when UFO data is not yet in IndexedDB -->
  <div id="upload-screen">
    <div class="inner">
      <a href="index.html" class="back-link">Back to playxcom.online</a>
      <h1>OPENXCOM</h1>
      <h2>// UPLOAD GAME DATA</h2>
      <p>
        OpenXcom requires the original <strong>X-COM: UFO Defense</strong> game data to play.
        Upload your <strong>UFO/</strong> data folder below. The files will be
        stored in your browser and persist across sessions.
      </p>
      <p>
        Need the game? Grab it on
        <a href="https://store.steampowered.com/app/7760/XCOM_UFO_Defense/" target="_blank" rel="noopener">Steam</a> or
        <a href="https://www.gog.com/game/xcom_ufo_defense" target="_blank" rel="noopener">GOG</a>
        for under $2.
      </p>

      <div id="drop-zone">
        <div class="icon">&#128193;</div>
        <div class="label">Drop your UFO data folder here</div>
        <div class="sublabel">or click to browse</div>
      </div>
      <input type="file" id="file-input" webkitdirectory multiple>
      <div id="file-list"></div>
      <button id="upload-btn">INSTALL GAME DATA</button>
      <div id="upload-progress"></div>

      <p class="note">
        Look for the folder containing GEODATA, GEOGRAPH, MAPS, SOUND, etc.<br><br>
        <strong>Steam (Windows):</strong> <code>C:\Program Files\Steam\...\XCom UFO Defense\XCOM\</code><br>
        <strong>Steam (macOS):</strong> <code>~/Library/Application Support/Steam/.../XCOM/</code><br>
        <strong>Steam (Linux):</strong> <code>~/.local/share/Steam/.../XCOM/</code><br>
        <strong>GOG (Windows):</strong> <code>C:\GOG Games\X-COM UFO Defense\</code>
      </p>

      <!-- Optional: restore saves alongside game data -->
      <div id="restore-saves-section" style="margin-top: 32px; padding-top: 24px; border-top: 1px solid var(--border);">
        <p style="color: var(--text-dim); font-size: 14px; margin-bottom: 12px;">
          <strong style="color: var(--text);">Have a save backup?</strong>
          If you previously exported your saves, you can restore them here
          before starting the game.
        </p>
        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
          <button id="restore-saves-btn" style="padding: 8px 20px; background: var(--card); color: var(--text); border: 1px solid var(--border); border-radius: 5px; cursor: pointer; font-size: 14px; font-family: var(--sans); transition: border-color 0.2s;">Import Saves (.zip or .sav)</button>
          <span id="restore-saves-status" style="font-family: var(--mono); font-size: 13px; color: var(--green);"></span>
        </div>
        <input type="file" id="restore-saves-input" multiple style="display:none;">
      </div>
    </div>

    <div id="upload-footer">
      <a href="index.html">playxcom.online</a> &middot;
      <a href="https://github.com/mrmrcoleman/OpenXcomWASM" target="_blank" rel="noopener">GitHub</a> &middot;
      GPL v3 &middot; X-COM: UFO Defense &copy; Mythos Games / MicroProse
    </div>
  </div>

  <!-- Toolbar (visible during gameplay) -->
  <div id="toolbar">
    <div id="toolbar-toggle">&#9881;</div>
    <div id="toolbar-menu">
      <button id="btn-export">&#128190; Export Saves</button>
      <button id="btn-import">&#128194; Import Saves</button>
      <div class="sep"></div>
      <button id="btn-reset" class="danger">&#128465; Reset All Data</button>
    </div>
  </div>

  <!-- Import modal -->
  <div class="modal-overlay" id="import-modal">
    <div class="modal-box">
      <h3>Import Saves</h3>
      <p>Upload a <strong>.zip</strong> file containing your exported saves,
         or individual <strong>.sav</strong> files. Existing saves with the
         same name will be overwritten.</p>
      <div class="btn-row">
        <button class="btn-cancel" id="import-cancel">Cancel</button>
        <button class="btn-confirm" id="import-choose">Choose File(s)</button>
      </div>
      <input type="file" id="import-file-input" multiple>
      <div class="modal-status" id="import-status"></div>
    </div>
  </div>

  <!-- Reset confirm modal -->
  <div class="modal-overlay" id="reset-modal">
    <div class="modal-box">
      <h3>Reset All Data</h3>
      <p>This will <strong>permanently delete</strong> all uploaded game data
         and saved games from your browser. You will need to upload the UFO
         data again.</p>
      <div class="btn-row">
        <button class="btn-cancel" id="reset-cancel">Cancel</button>
        <button class="btn-danger" id="reset-confirm">Delete Everything</button>
      </div>
    </div>
  </div>

  <!-- Error overlay -->
  <div id="error-overlay">
    <div class="error-inner">
      <h2 id="error-title">SOMETHING WENT WRONG</h2>
      <p id="error-message">The game failed to start. Details below.</p>
      <div class="error-detail" id="error-detail"></div>
      <p style="font-size: 13px; color: var(--text-dim);">Startup log:</p>
      <div class="error-log" id="error-log"></div>
      <div class="error-actions">
        <button class="btn-retry" onclick="location.reload()">Reload Page</button>
        <button class="btn-reset-err" id="error-reset-btn">Reset All Data</button>
      </div>
    </div>
  </div>

  <!-- JSZip for save export/import -->
  <script src="jszip.min.js"></script>

  <script>
    /* ------------------------------------------------------------------ */
    /*  Globals                                                           */
    /* ------------------------------------------------------------------ */
    var statusEl        = document.getElementById('status');
    var canvasEl        = document.getElementById('canvas');
    var uploadScreen    = document.getElementById('upload-screen');
    var dropZone        = document.getElementById('drop-zone');
    var fileInput       = document.getElementById('file-input');
    var fileListEl      = document.getElementById('file-list');
    var uploadBtn       = document.getElementById('upload-btn');
    var uploadProgress  = document.getElementById('upload-progress');

    var PERSIST_DIR     = '/home/web_user/.local/share/openxcom';
    var UFO_DIR         = PERSIST_DIR + '/UFO';
    var REQUIRED_DIRS   = ['GEODATA','GEOGRAPH','MAPS','ROUTES','SOUND','TERRAIN','UFOGRAPH','UNITS'];

    /* ------------------------------------------------------------------ */
    /*  Diagnostic log                                                    */
    /* ------------------------------------------------------------------ */
    var _diagLog = [];
    function diagLog(msg, level) {
      level = level || 'info';
      var ts = new Date().toISOString().slice(11, 23);
      var entry = { ts: ts, msg: msg, level: level };
      _diagLog.push(entry);
      if (level === 'fail') console.error('[DIAG] ' + msg);
      else if (level === 'warn') console.warn('[DIAG] ' + msg);
      else console.log('[DIAG] ' + msg);
    }

    function getDiagHTML() {
      return _diagLog.map(function(e) {
        var cls = e.level === 'ok' ? 'log-ok' : e.level === 'warn' ? 'log-warn' : e.level === 'fail' ? 'log-fail' : '';
        var prefix = e.level === 'ok' ? '  OK  ' : e.level === 'warn' ? ' WARN ' : e.level === 'fail' ? ' FAIL ' : ' INFO ';
        return '<span class="' + cls + '">' + e.ts + prefix + e.msg + '</span>';
      }).join('\n');
    }

    /* ------------------------------------------------------------------ */
    /*  Error overlay                                                     */
    /* ------------------------------------------------------------------ */
    function showError(title, message, detail) {
      var overlay = document.getElementById('error-overlay');
      document.getElementById('error-title').textContent = title || 'SOMETHING WENT WRONG';
      document.getElementById('error-message').textContent = message || 'The game failed to start.';
      document.getElementById('error-detail').textContent = detail || 'No additional details.';
      document.getElementById('error-log').innerHTML = getDiagHTML();
      overlay.style.display = 'block';
      uploadScreen.style.display = 'none';
      statusEl.style.display = 'none';
    }

    document.getElementById('error-reset-btn').addEventListener('click', function() {
      var dbName = PERSIST_DIR;
      indexedDB.deleteDatabase(dbName);
      location.reload();
    });

    /* Global error handler to catch unhandled exceptions */
    window.addEventListener('error', function(event) {
      diagLog('Uncaught error: ' + event.message + ' at ' + (event.filename || '?') + ':' + (event.lineno || '?'), 'fail');
      if (document.getElementById('error-overlay').style.display !== 'block') {
        showError('RUNTIME ERROR', 'The game crashed unexpectedly.', event.message + '\n\nFile: ' + (event.filename || 'unknown') + '\nLine: ' + (event.lineno || '?'));
      }
    });

    window.addEventListener('unhandledrejection', function(event) {
      var reason = event.reason ? (event.reason.message || String(event.reason)) : 'Unknown';
      diagLog('Unhandled promise rejection: ' + reason, 'fail');
    });

    /* ------------------------------------------------------------------ */
    /*  Pre-flight capability checks                                      */
    /* ------------------------------------------------------------------ */
    function runPreflightChecks() {
      var allGood = true;

      /* WebAssembly */
      if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
        diagLog('WebAssembly supported', 'ok');
      } else {
        diagLog('WebAssembly NOT supported', 'fail');
        allGood = false;
      }

      /* IndexedDB */
      if (window.indexedDB) {
        diagLog('IndexedDB available', 'ok');
      } else {
        diagLog('IndexedDB NOT available (private browsing?)', 'fail');
        allGood = false;
      }

      /* Canvas / WebGL */
      try {
        var testCanvas = document.createElement('canvas');
        var gl = testCanvas.getContext('webgl') || testCanvas.getContext('webgl2') || testCanvas.getContext('experimental-webgl');
        if (gl) {
          diagLog('WebGL supported (' + gl.getParameter(gl.VERSION) + ')', 'ok');
        } else {
          diagLog('WebGL NOT available â€” game may not render', 'warn');
        }
      } catch(e) {
        diagLog('WebGL check failed: ' + e.message, 'warn');
      }

      /* Memory â€” rough check for 128MB+ */
      try {
        var testBuf = new ArrayBuffer(128 * 1024 * 1024);
        if (testBuf.byteLength === 128 * 1024 * 1024) {
          diagLog('Memory allocation test passed (128 MB)', 'ok');
        }
        testBuf = null;
      } catch(e) {
        diagLog('Memory allocation test failed â€” may not have enough RAM', 'warn');
      }

      /* Browser info */
      diagLog('User agent: ' + navigator.userAgent, 'info');
      diagLog('Platform: ' + (navigator.platform || 'unknown'), 'info');

      if (!allGood) {
        showError(
          'BROWSER NOT SUPPORTED',
          'Your browser is missing features required to run OpenXcom.',
          'See the startup log below for details. Try a recent version of Chrome, Firefox, Edge, or Safari.'
        );
      }

      return allGood;
    }

    /* Files selected by the user (array of {path, file} objects) */
    var pendingFiles = [];

    /* ------------------------------------------------------------------ */
    /*  Canvas scaling                                                    */
    /* ------------------------------------------------------------------ */
    function fitCanvas() {
      var cw = canvasEl.width, ch = canvasEl.height;
      if (!cw || !ch) return;
      var ratio = cw / ch;
      var winW = window.innerWidth, winH = window.innerHeight;
      var w, h;
      if (winW / winH > ratio) { h = winH; w = Math.round(h * ratio); }
      else                     { w = winW; h = Math.round(w / ratio); }
      canvasEl.style.width  = w + 'px';
      canvasEl.style.height = h + 'px';
    }
    window.addEventListener('resize', fitCanvas);
    canvasEl.addEventListener('click', function() { canvasEl.focus(); });

    /* ------------------------------------------------------------------ */
    /*  IDBFS helpers                                                     */
    /* ------------------------------------------------------------------ */
    function mkdirp(path) {
      var parts = path.split('/').filter(Boolean);
      var cur = '';
      for (var i = 0; i < parts.length; i++) {
        cur += '/' + parts[i];
        try { Module.FS.mkdir(cur); } catch(e) { /* already exists */ }
      }
    }

    function syncFromIDB(cb) {
      Module.FS.syncfs(true, function(err) {
        if (err) console.error('syncfs(populate) error:', err);
        cb(err);
      });
    }

    function syncToIDB(cb) {
      Module.FS.syncfs(false, function(err) {
        if (err) console.error('syncfs(persist) error:', err);
        if (cb) cb(err);
      });
    }

    /** Check whether REQUIRED_DIRS exist under UFO_DIR */
    function hasUFOData() {
      try {
        var entries = Module.FS.readdir(UFO_DIR);
        var upper = entries.map(function(e) { return e.toUpperCase(); });
        for (var i = 0; i < REQUIRED_DIRS.length; i++) {
          if (upper.indexOf(REQUIRED_DIRS[i]) === -1) return false;
        }
        return true;
      } catch(e) {
        return false;
      }
    }

    /**
     * Deeper validation: check for key files that OpenXcom needs.
     * Returns { ok: bool, found: [...], missing: [...], details: string }
     */
    var KEY_FILES = [
      'GEODATA/WORLD.DAT',
      'GEODATA/OBDATA.DAT',
      'GEOGRAPH/BASEBITS.PCK',
      'GEOGRAPH/INTICON.PCK',
      'MAPS/XBASE_00.MAP',
      'ROUTES/XBASE_00.RMP',
      'SOUND/SAMPLE.CAT',
      'TERRAIN/BLANKS.MCD',
      'UFOGRAPH/CURSOR.PCK',
      'UNITS/XCOM_0.PCK',
    ];

    function validateGameData() {
      var found = [];
      var missing = [];
      var totalFiles = 0;

      /* Count total files and check key files */
      for (var d = 0; d < REQUIRED_DIRS.length; d++) {
        try {
          var dirPath = UFO_DIR + '/' + REQUIRED_DIRS[d];
          /* Try both original case and uppercase */
          var entries;
          try { entries = Module.FS.readdir(dirPath); } catch(e) {
            try { entries = Module.FS.readdir(UFO_DIR + '/' + REQUIRED_DIRS[d].toLowerCase()); } catch(e2) {
              entries = [];
            }
          }
          var fileCount = entries.filter(function(e) { return e !== '.' && e !== '..'; }).length;
          totalFiles += fileCount;
          diagLog('  ' + REQUIRED_DIRS[d] + '/: ' + fileCount + ' file(s)');
        } catch(e) {
          diagLog('  ' + REQUIRED_DIRS[d] + '/: NOT FOUND', 'warn');
        }
      }

      for (var i = 0; i < KEY_FILES.length; i++) {
        var filePath = UFO_DIR + '/' + KEY_FILES[i];
        try {
          var stat = Module.FS.stat(filePath);
          if (stat.size > 0) {
            found.push(KEY_FILES[i]);
          } else {
            missing.push(KEY_FILES[i] + ' (empty)');
          }
        } catch(e) {
          /* Try case-insensitive: uppercase whole path */
          try {
            var altPath = UFO_DIR + '/' + KEY_FILES[i].toUpperCase();
            var stat2 = Module.FS.stat(altPath);
            if (stat2.size > 0) {
              found.push(KEY_FILES[i]);
            } else {
              missing.push(KEY_FILES[i] + ' (empty)');
            }
          } catch(e2) {
            missing.push(KEY_FILES[i]);
          }
        }
      }

      var ok = missing.length <= 2; /* Allow a couple missing â€” some versions differ */
      var details = 'Total files in UFO/: ~' + totalFiles + '\n' +
        'Key files found: ' + found.length + '/' + KEY_FILES.length + '\n';
      if (missing.length > 0) {
        details += 'Missing: ' + missing.join(', ');
      }

      return { ok: ok, found: found, missing: missing, details: details };
    }

    /* ------------------------------------------------------------------ */
    /*  Upload screen logic                                               */
    /* ------------------------------------------------------------------ */
    dropZone.addEventListener('click', function() { fileInput.click(); });

    dropZone.addEventListener('dragover', function(e) {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.add('drag-over');
    });
    dropZone.addEventListener('dragleave', function(e) {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.remove('drag-over');
    });
    dropZone.addEventListener('drop', function(e) {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.remove('drag-over');
      handleDroppedItems(e.dataTransfer.items);
    });

    fileInput.addEventListener('change', function() {
      handleSelectedFiles(fileInput.files);
    });

    /** Process files from the directory picker (<input webkitdirectory>) */
    function handleSelectedFiles(fileList) {
      pendingFiles = [];
      for (var i = 0; i < fileList.length; i++) {
        var f = fileList[i];
        /* webkitRelativePath gives e.g. "UFO/GEODATA/foo.dat" */
        var rel = f.webkitRelativePath || f.name;
        /* Strip the top-level directory name so we get "GEODATA/foo.dat" */
        var parts = rel.split('/');
        if (parts.length > 1) parts.shift();
        var path = parts.join('/');
        pendingFiles.push({ path: path, file: f });
      }
      showPendingFiles();
    }

    /** Process items from drag-and-drop (supports directory entries) */
    function handleDroppedItems(items) {
      pendingFiles = [];
      var promises = [];
      for (var i = 0; i < items.length; i++) {
        var entry = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
        if (entry) {
          promises.push(readEntryRecursive(entry, '', true));
        }
      }
      Promise.all(promises).then(function() {
        diagLog('Drag-and-drop: read ' + pendingFiles.length + ' file(s)');
        showPendingFiles();
      });
    }

    /**
     * Recursively read a FileSystemEntry.
     * isTopLevel=true for the initially dropped folder (its name is stripped).
     *
     * Firefox's readEntries() may not return all entries in one call.
     * The spec requires calling it repeatedly until it returns empty.
     */
    function readEntryRecursive(entry, basePath, isTopLevel) {
      return new Promise(function(resolve) {
        if (entry.isFile) {
          entry.file(function(f) {
            var path = basePath ? basePath + '/' + f.name : f.name;
            pendingFiles.push({ path: path, file: f });
            resolve();
          }, function() { resolve(); });
        } else if (entry.isDirectory) {
          var reader = entry.createReader();
          var childBase = isTopLevel ? '' : (basePath ? basePath + '/' + entry.name : entry.name);
          var allEntries = [];

          function readBatch() {
            reader.readEntries(function(batch) {
              if (batch.length === 0) {
                var ps = [];
                for (var i = 0; i < allEntries.length; i++) {
                  ps.push(readEntryRecursive(allEntries[i], childBase, false));
                }
                Promise.all(ps).then(resolve);
              } else {
                for (var i = 0; i < batch.length; i++) {
                  allEntries.push(batch[i]);
                }
                readBatch();
              }
            }, function() { resolve(); });
          }
          readBatch();
        } else {
          resolve();
        }
      });
    }

    function showPendingFiles() {
      if (pendingFiles.length === 0) return;

      /* Collect top-level directory names */
      var dirs = {};
      pendingFiles.forEach(function(f) {
        var d = f.path.split('/')[0].toUpperCase();
        dirs[d] = (dirs[d] || 0) + 1;
      });
      var topDirs = Object.keys(dirs).sort();

      /* Check: do the expected data directories appear at the top level? */
      var foundAtTop = REQUIRED_DIRS.filter(function(r) { return topDirs.indexOf(r) !== -1; });
      var missingAtTop = REQUIRED_DIRS.filter(function(r) { return topDirs.indexOf(r) === -1; });

      /* Check: are they nested one level deeper? (common mistake) */
      var nestedPrefix = null;
      if (missingAtTop.length > 4) {
        /* Most required dirs missing at top â€” check if they're inside a subdirectory */
        var secondLevel = {};
        pendingFiles.forEach(function(f) {
          var parts = f.path.split('/');
          if (parts.length >= 2) {
            var key = parts[0].toUpperCase() + '/' + parts[1].toUpperCase();
            secondLevel[key] = true;
          }
        });
        for (var i = 0; i < topDirs.length; i++) {
          var prefix = topDirs[i];
          var matchCount = REQUIRED_DIRS.filter(function(r) {
            return secondLevel[prefix + '/' + r];
          }).length;
          if (matchCount >= 4) {
            nestedPrefix = prefix;
            break;
          }
        }
      }

      if (nestedPrefix) {
        /* Auto-fix: strip the extra nesting level */
        diagLog('Detected nested data folder: ' + nestedPrefix + '/ â€” auto-correcting paths', 'warn');
        var prefixLower = nestedPrefix.toLowerCase() + '/';
        pendingFiles = pendingFiles.filter(function(f) {
          return f.path.toUpperCase().startsWith(nestedPrefix + '/');
        }).map(function(f) {
          return { path: f.path.substring(f.path.indexOf('/') + 1), file: f.file };
        });
        /* Recalculate dirs after fix */
        dirs = {};
        pendingFiles.forEach(function(f) {
          var d = f.path.split('/')[0].toUpperCase();
          dirs[d] = (dirs[d] || 0) + 1;
        });
        topDirs = Object.keys(dirs).sort();
        foundAtTop = REQUIRED_DIRS.filter(function(r) { return topDirs.indexOf(r) !== -1; });
        missingAtTop = REQUIRED_DIRS.filter(function(r) { return topDirs.indexOf(r) === -1; });
      }

      /* Build the display summary */
      var summary = topDirs.map(function(d) {
        var isExpected = REQUIRED_DIRS.indexOf(d) !== -1;
        return (isExpected ? '&#9989; ' : '') + d + '/ (' + dirs[d] + ' files)';
      }).join('<br>');

      var warning = '';
      if (missingAtTop.length > 0 && missingAtTop.length <= 4) {
        warning = '<br><span style="color: #fa0;">&#9888; Missing expected folders: ' + missingAtTop.join(', ') +
          '</span><br><span style="color: var(--text-dim); font-size: 12px;">The game may still work, but some features could be broken.</span>';
      } else if (missingAtTop.length > 4) {
        warning = '<br><span style="color: #f55;">&#9888; This doesn\'t look like X-COM game data.</span>' +
          '<br><span style="color: var(--text-dim); font-size: 12px;">Expected folders like GEODATA, GEOGRAPH, MAPS, SOUND, etc. ' +
          'Make sure you\'re selecting the folder that directly contains these subdirectories.</span>';
      }

      if (nestedPrefix) {
        warning += '<br><span style="color: var(--green); font-size: 12px;">&#8627; Auto-corrected: found data inside ' + nestedPrefix + '/ subfolder.</span>';
      }

      fileListEl.innerHTML = '<strong>' + pendingFiles.length + ' files found:</strong><br>' + summary + warning;
      uploadBtn.style.display = 'block';

      diagLog('Upload analysis: ' + pendingFiles.length + ' files, ' + foundAtTop.length + '/' + REQUIRED_DIRS.length +
        ' expected dirs found' + (nestedPrefix ? ' (auto-fixed from ' + nestedPrefix + '/)' : ''));
    }

    /** Write pending files into the Emscripten VFS and persist to IndexedDB */
    uploadBtn.addEventListener('click', function() {
      uploadBtn.style.display = 'none';
      uploadProgress.style.display = 'block';
      uploadProgress.textContent = 'Installing game data...';

      var done = 0;
      var total = pendingFiles.length;

      function writeNext() {
        if (done >= total) {
          uploadProgress.textContent = 'Validating game data...';
          diagLog('Upload complete â€” validating game data...');

          var validation = validateGameData();
          diagLog('Validation: ' + validation.found.length + '/' + KEY_FILES.length +
            ' key files found, ' + validation.missing.length + ' missing',
            validation.ok ? 'ok' : 'warn');

          if (!validation.ok) {
            diagLog('Validation failed: ' + validation.details, 'fail');
            uploadProgress.style.display = 'none';
            showError(
              'INCOMPLETE GAME DATA',
              'The uploaded files appear to be missing key X-COM data files. ' +
              'Make sure you selected the correct folder â€” it should directly contain subfolders like GEODATA, GEOGRAPH, MAPS, SOUND, etc.',
              validation.details +
              '\n\nCommon fixes:\n' +
              '- Select the XCOM/ folder, not its parent directory\n' +
              '- On Steam: look inside steamapps/common/XCom UFO Defense/XCOM/\n' +
              '- On GOG: look inside the X-COM installation folder\n' +
              '- Make sure the game is fully installed (not just a shortcut)'
            );
            return;
          }

          uploadProgress.textContent = 'Saving to browser storage...';
          syncToIDB(function() {
            uploadProgress.textContent = 'Done!';
            setTimeout(startGame, 500);
          });
          return;
        }
        var item = pendingFiles[done];
        var reader = new FileReader();
        reader.onload = function() {
          var fullPath = UFO_DIR + '/' + item.path;
          /* Ensure parent directories exist */
          var dirParts = fullPath.split('/');
          dirParts.pop(); /* remove filename */
          mkdirp(dirParts.join('/'));
          Module.FS.writeFile(fullPath, new Uint8Array(reader.result));
          done++;
          if (done % 20 === 0 || done === total) {
            uploadProgress.textContent = 'Installing... ' + done + '/' + total;
          }
          /* Yield to the browser periodically */
          if (done % 50 === 0) setTimeout(writeNext, 0);
          else writeNext();
        };
        reader.readAsArrayBuffer(item.file);
      }
      writeNext();
    });

    /* ------------------------------------------------------------------ */
    /*  Restore saves on upload screen                                    */
    /* ------------------------------------------------------------------ */
    var restoreBtn    = document.getElementById('restore-saves-btn');
    var restoreInput  = document.getElementById('restore-saves-input');
    var restoreStatus = document.getElementById('restore-saves-status');

    restoreBtn.addEventListener('click', function() { restoreInput.click(); });

    restoreInput.addEventListener('change', function() {
      var files = restoreInput.files;
      if (!files || files.length === 0) return;

      var firstFile = files[0];
      var isZip = firstFile.name.toLowerCase().endsWith('.zip');

      if (isZip) {
        restoreFromZip(firstFile);
      } else {
        restoreLooseFiles(files);
      }
    });

    function restoreFromZip(file) {
      restoreStatus.textContent = 'Reading zip...';
      var reader = new FileReader();
      reader.onload = function() {
        JSZip.loadAsync(reader.result).then(function(zip) {
          var entries = [];
          zip.forEach(function(relativePath, zipEntry) {
            if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.sav'))
              entries.push(zipEntry);
          });
          if (entries.length === 0) {
            restoreStatus.textContent = 'No .sav files found in the zip.';
            restoreInput.value = '';
            return;
          }
          restoreStatus.textContent = 'Restoring ' + entries.length + ' save(s)...';
          var done = 0;
          function next() {
            if (done >= entries.length) {
              restoreStatus.textContent = entries.length + ' save(s) queued for import.';
              restoreInput.value = '';
              /* Store for writing after IDBFS is mounted */
              window._pendingRestoreSaves = entries.map(function(e) { return e; });
              /* Actually write them now if FS is ready */
              writePendingRestores();
              return;
            }
            entries[done].async('uint8array').then(function(data) {
              entries[done]._data = data;
              done++;
              next();
            });
          }
          next();
        }).catch(function(err) {
          restoreStatus.textContent = 'Error reading zip: ' + err;
        });
      };
      reader.readAsArrayBuffer(file);
    }

    function restoreLooseFiles(fileList) {
      var savFiles = [];
      for (var i = 0; i < fileList.length; i++) {
        if (fileList[i].name.toLowerCase().endsWith('.sav'))
          savFiles.push(fileList[i]);
      }
      if (savFiles.length === 0) {
        restoreStatus.textContent = 'No .sav files found.';
        restoreInput.value = '';
        return;
      }
      restoreStatus.textContent = 'Reading ' + savFiles.length + ' file(s)...';
      window._pendingRestoreLoose = [];
      var done = 0;
      function readNext() {
        if (done >= savFiles.length) {
          restoreStatus.textContent = savFiles.length + ' save(s) queued for import.';
          restoreInput.value = '';
          writePendingRestores();
          return;
        }
        var f = savFiles[done];
        var reader = new FileReader();
        reader.onload = function() {
          window._pendingRestoreLoose.push({ name: f.name, data: new Uint8Array(reader.result) });
          done++;
          readNext();
        };
        reader.readAsArrayBuffer(f);
      }
      readNext();
    }

    /** Write pending restore saves into the VFS (only works after IDBFS mount) */
    function writePendingRestores() {
      /* If the FS isn't mounted yet, saves will be written in startGame */
      if (!window._idbfsMounted) return;

      var savesDir = PERSIST_DIR + '/xcom1';
      mkdirp(savesDir);

      /* From zip */
      if (window._pendingRestoreSaves) {
        window._pendingRestoreSaves.forEach(function(entry) {
          if (entry._data) {
            var fullPath = PERSIST_DIR + '/' + entry.name;
            var dirParts = fullPath.split('/'); dirParts.pop();
            mkdirp(dirParts.join('/'));
            Module.FS.writeFile(fullPath, entry._data);
          }
        });
        delete window._pendingRestoreSaves;
      }

      /* From loose files */
      if (window._pendingRestoreLoose) {
        window._pendingRestoreLoose.forEach(function(item) {
          Module.FS.writeFile(savesDir + '/' + item.name, item.data);
        });
        delete window._pendingRestoreLoose;
      }

      syncToIDB(function() {
        restoreStatus.textContent = 'Saves restored successfully!';
      });
    }

    /* ------------------------------------------------------------------ */
    /*  Game startup orchestration                                        */
    /* ------------------------------------------------------------------ */
    function showUploadScreen() {
      uploadScreen.style.display = 'block';
      statusEl.style.display = 'none';
    }

    function startGame() {
      diagLog('startGame() called');
      uploadScreen.style.display = 'none';
      canvasEl.style.display = 'block';
      toolbar.style.display = 'block';
      statusEl.textContent = 'Starting OpenXcom...';
      statusEl.style.display = 'block';

      /* Resume any suspended AudioContext (browsers block autoplay without
         a user gesture). This click/tap that triggers startGame counts. */
      try {
        var ac = window.AudioContext || window.webkitAudioContext;
        if (ac && Module && Module.SDL && Module.SDL.audioContext) {
          if (Module.SDL.audioContext.state === 'suspended') {
            Module.SDL.audioContext.resume().then(function() {
              diagLog('AudioContext resumed', 'ok');
            });
          }
        }
      } catch(ignore) {}

      try {
        diagLog('Calling Module.callMain()...');
        Module.callMain();
        diagLog('Module.callMain() returned successfully', 'ok');

        /* Suppress browser context menu on right-click so it doesn't
           interfere with right-click-drag scrolling in the game. */
        canvasEl.addEventListener('contextmenu', function(e) {
          e.preventDefault();
        });
      } catch(e) {
        diagLog('callMain() threw: ' + (e.message || e), 'fail');
        showError(
          'GAME FAILED TO START',
          'OpenXcom crashed during startup. This can happen if game data files are incomplete or corrupted.',
          String(e.message || e) + '\n\n' + (e.stack || '')
        );
        return;
      }

      /* Log canvas state right after callMain */
      diagLog('Canvas intrinsic size: ' + canvasEl.width + 'x' + canvasEl.height);
      diagLog('Canvas CSS size: ' + canvasEl.style.width + ' x ' + canvasEl.style.height);
      diagLog('Canvas display: ' + canvasEl.style.display);

      /* Check what GL context the canvas has */
      try {
        var gl = canvasEl.getContext('webgl2') || canvasEl.getContext('webgl');
        if (gl) {
          diagLog('Canvas has WebGL context: ' + gl.getParameter(gl.VERSION), 'ok');
          var vp = gl.getParameter(gl.VIEWPORT);
          diagLog('WebGL viewport: ' + vp[0] + ',' + vp[1] + ' ' + vp[2] + 'x' + vp[3]);
        } else {
          /* SDL2 might be using 2D canvas instead */
          var ctx2d = canvasEl.getContext('2d');
          if (ctx2d) {
            diagLog('Canvas has 2D context (no WebGL)');
          } else {
            diagLog('Canvas has no rendering context!', 'warn');
          }
        }
      } catch(e) {
        diagLog('Could not inspect canvas context: ' + e.message, 'warn');
      }

      /* Log any engine stderr captured so far */
      if (_engineErrors.length > 0) {
        diagLog('Engine stderr (' + _engineErrors.length + ' lines): ' + _engineErrors.slice(-5).join(' | '), 'warn');
      } else {
        diagLog('No engine stderr output', 'ok');
      }

      statusEl.textContent = 'Running...';
      setTimeout(function() { statusEl.style.display = 'none'; }, 2000);
      setTimeout(fitCanvas, 200);
      setTimeout(fitCanvas, 1000);

      /* Watchdog: check canvas state at 3s, 8s, 15s */
      [3000, 8000, 15000].forEach(function(delay) {
        setTimeout(function() {
          var w = canvasEl.width, h = canvasEl.height;
          diagLog('Watchdog @' + (delay/1000) + 's â€” canvas: ' + w + 'x' + h +
            ', display: ' + canvasEl.style.display +
            ', CSS: ' + canvasEl.style.width + ' x ' + canvasEl.style.height);

          if (w === 0 || h === 0) {
            diagLog('Canvas has zero dimensions at ' + (delay/1000) + 's!', 'fail');
            if (delay >= 8000) {
              showError(
                'BLACK SCREEN',
                'The game engine started but the canvas has zero dimensions. The game may have failed to initialize its display.',
                'Canvas size: ' + w + 'x' + h + '\n\nRecent engine output:\n' + _engineErrors.slice(-10).join('\n')
              );
            }
            return;
          }

          /* Try to read pixels via WebGL to check if anything is being drawn */
          try {
            var gl = canvasEl.getContext('webgl2') || canvasEl.getContext('webgl');
            if (gl) {
              var pixels = new Uint8Array(4 * 4);  /* Read a small 2x2 patch from center */
              gl.readPixels(
                Math.floor(w/2), Math.floor(h/2), 2, 2,
                gl.RGBA, gl.UNSIGNED_BYTE, pixels
              );
              var allZero = true;
              for (var i = 0; i < pixels.length; i++) {
                if (pixels[i] !== 0) { allZero = false; break; }
              }
              if (allZero && delay >= 8000) {
                diagLog('Canvas center pixels are all black at ' + (delay/1000) + 's', 'warn');
                statusEl.textContent = 'Game may be loading... if the screen stays black, try reloading.';
                statusEl.style.display = 'block';
              } else if (!allZero) {
                diagLog('Canvas is rendering content at ' + (delay/1000) + 's', 'ok');
              }
            }
          } catch(e) { /* ignore readPixels errors */ }
        }, delay);
      });
    }

    /**
     * Called once the Emscripten runtime is ready.
     * Sets up IDBFS, checks for existing game data, and either starts
     * the game or shows the upload screen.
     */
    function onEngineReady() {
      diagLog('Emscripten runtime initialized', 'ok');
      statusEl.textContent = 'Checking for game data...';

      try {
        mkdirp(PERSIST_DIR);
        Module.FS.mount(Module.FS.filesystems.IDBFS, {}, PERSIST_DIR);
        diagLog('IDBFS mounted at ' + PERSIST_DIR, 'ok');
      } catch(e) {
        diagLog('IDBFS mount failed: ' + e.message, 'fail');
        showError(
          'STORAGE ERROR',
          'Failed to set up browser storage. This can happen in private/incognito mode.',
          e.message + '\n\n' + (e.stack || '')
        );
        return;
      }

      syncFromIDB(function(err) {
        if (err) {
          diagLog('syncfs(populate) error: ' + err, 'warn');
        } else {
          diagLog('IndexedDB synced to VFS', 'ok');
        }
        window._idbfsMounted = true;

        if (window._pendingRestoreSaves || window._pendingRestoreLoose) {
          writePendingRestores();
        }

        if (hasUFOData()) {
          diagLog('UFO game data found in storage', 'ok');
          var validation = validateGameData();
          diagLog('Data validation: ' + validation.found.length + '/' + KEY_FILES.length +
            ' key files' + (validation.missing.length > 0 ? ', missing: ' + validation.missing.join(', ') : ''),
            validation.ok ? 'ok' : 'warn');
          startGame();
        } else {
          diagLog('No UFO game data found â€” showing upload screen');
          showUploadScreen();
        }
      });
    }

    /* ------------------------------------------------------------------ */
    /*  Toolbar: export, import, reset                                    */
    /* ------------------------------------------------------------------ */
    var toolbar      = document.getElementById('toolbar');
    var toolbarMenu  = document.getElementById('toolbar-menu');
    var toolbarToggle = document.getElementById('toolbar-toggle');

    toolbarToggle.addEventListener('click', function(e) {
      e.stopPropagation();
      toolbarMenu.style.display = toolbarMenu.style.display === 'block' ? 'none' : 'block';
    });
    document.addEventListener('click', function() { toolbarMenu.style.display = 'none'; });

    /* ---- Export saves ---- */
    document.getElementById('btn-export').addEventListener('click', function() {
      toolbarMenu.style.display = 'none';
      exportSaves();
    });

    function collectFiles(dir, base) {
      var result = [];
      try {
        var entries = Module.FS.readdir(dir);
      } catch(e) { return result; }
      for (var i = 0; i < entries.length; i++) {
        if (entries[i] === '.' || entries[i] === '..') continue;
        var full = dir + '/' + entries[i];
        var rel  = base ? base + '/' + entries[i] : entries[i];
        var stat;
        try { stat = Module.FS.stat(full); } catch(e) { continue; }
        if (Module.FS.isDir(stat.mode)) {
          result = result.concat(collectFiles(full, rel));
        } else {
          result.push({ path: rel, fullPath: full });
        }
      }
      return result;
    }

    function exportSaves() {
      /* First sync to make sure IDBFS is up to date */
      syncToIDB(function() {
        var savesDir = PERSIST_DIR + '/xcom1';
        var files = collectFiles(savesDir, 'xcom1');

        /* Also grab options.cfg if it exists */
        try {
          Module.FS.stat(PERSIST_DIR + '/options.cfg');
          files.push({ path: 'options.cfg', fullPath: PERSIST_DIR + '/options.cfg' });
        } catch(e) {}

        if (files.length === 0) {
          alert('No save data found to export.');
          return;
        }

        var zip = new JSZip();
        for (var i = 0; i < files.length; i++) {
          try {
            var data = Module.FS.readFile(files[i].fullPath);
            zip.file(files[i].path, data);
          } catch(e) {
            console.warn('Could not read ' + files[i].fullPath, e);
          }
        }

        zip.generateAsync({ type: 'blob' }).then(function(blob) {
          var a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          var d = new Date();
          a.download = 'openxcom-saves-' + d.toISOString().slice(0,10) + '.zip';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(a.href);
        });
      });
    }

    /* ---- Import saves ---- */
    var importModal     = document.getElementById('import-modal');
    var importFileInput = document.getElementById('import-file-input');
    var importStatus    = document.getElementById('import-status');

    document.getElementById('btn-import').addEventListener('click', function() {
      toolbarMenu.style.display = 'none';
      importStatus.textContent = '';
      importModal.classList.add('active');
    });
    document.getElementById('import-cancel').addEventListener('click', function() {
      importModal.classList.remove('active');
    });
    document.getElementById('import-choose').addEventListener('click', function() {
      importFileInput.click();
    });

    importFileInput.addEventListener('change', function() {
      var files = importFileInput.files;
      if (!files || files.length === 0) return;

      /* Check if the first file is a zip */
      var firstFile = files[0];
      var isZip = firstFile.name.toLowerCase().endsWith('.zip');

      if (isZip) {
        importFromZip(firstFile);
      } else {
        importLooseFiles(files);
      }
    });

    function importFromZip(file) {
      importStatus.textContent = 'Reading zip...';
      var reader = new FileReader();
      reader.onload = function() {
        JSZip.loadAsync(reader.result).then(function(zip) {
          var entries = [];
          zip.forEach(function(relativePath, zipEntry) {
            if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.sav'))
              entries.push(zipEntry);
          });
          if (entries.length === 0) {
            importStatus.textContent = 'No .sav files found in the zip.';
            importFileInput.value = '';
            return;
          }
          importStatus.textContent = 'Importing ' + entries.length + ' save(s)...';

          var done = 0;
          function nextEntry() {
            if (done >= entries.length) {
              finishImport(entries.length);
              return;
            }
            var entry = entries[done];
            entry.async('uint8array').then(function(data) {
              var fullPath = PERSIST_DIR + '/' + entry.name;
              var dirParts = fullPath.split('/');
              dirParts.pop();
              mkdirp(dirParts.join('/'));
              Module.FS.writeFile(fullPath, data);
              done++;
              if (done % 10 === 0) importStatus.textContent = 'Importing... ' + done + '/' + entries.length;
              if (done % 50 === 0) setTimeout(nextEntry, 0);
              else nextEntry();
            });
          }
          nextEntry();
        }).catch(function(err) {
          importStatus.textContent = 'Error reading zip: ' + err;
        });
      };
      reader.readAsArrayBuffer(file);
    }

    /** Import individual .sav files directly into xcom1/ */
    function importLooseFiles(fileList) {
      /* Filter to only .sav files */
      var savFiles = [];
      for (var i = 0; i < fileList.length; i++) {
        if (fileList[i].name.toLowerCase().endsWith('.sav'))
          savFiles.push(fileList[i]);
      }
      if (savFiles.length === 0) {
        importStatus.textContent = 'No .sav files found. Please select OpenXcom save files (.sav).';
        importFileInput.value = '';
        return;
      }

      var savesDir = PERSIST_DIR + '/xcom1';
      mkdirp(savesDir);
      importStatus.textContent = 'Importing ' + savFiles.length + ' save(s)...';
      var done = 0;
      var total = savFiles.length;

      function readNext() {
        if (done >= total) {
          finishImport(total);
          return;
        }
        var f = savFiles[done];
        var reader = new FileReader();
        reader.onload = function() {
          var fullPath = savesDir + '/' + f.name;
          Module.FS.writeFile(fullPath, new Uint8Array(reader.result));
          done++;
          importStatus.textContent = 'Importing... ' + done + '/' + total;
          if (done % 20 === 0) setTimeout(readNext, 0);
          else readNext();
        };
        reader.readAsArrayBuffer(f);
      }
      readNext();
    }

    function finishImport(count) {
      importStatus.textContent = 'Saving to browser storage...';
      syncToIDB(function() {
        importStatus.textContent = 'Import complete! (' + count + ' file' + (count !== 1 ? 's' : '') + ')';
        importFileInput.value = '';
        setTimeout(function() { importModal.classList.remove('active'); }, 1500);
      });
    }

    /* ---- Reset all data ---- */
    var resetModal = document.getElementById('reset-modal');

    document.getElementById('btn-reset').addEventListener('click', function() {
      toolbarMenu.style.display = 'none';
      resetModal.classList.add('active');
    });
    document.getElementById('reset-cancel').addEventListener('click', function() {
      resetModal.classList.remove('active');
    });
    document.getElementById('reset-confirm').addEventListener('click', function() {
      resetModal.classList.remove('active');
      statusEl.textContent = 'Deleting all data...';
      statusEl.style.display = 'block';

      /* Delete all entries from the IndexedDB database directly */
      var dbName = PERSIST_DIR;
      var req = indexedDB.deleteDatabase(dbName);
      req.onsuccess = function() {
        console.log('IndexedDB deleted:', dbName);
        window.location.reload();
      };
      req.onerror = function() {
        console.error('Failed to delete IndexedDB:', dbName);
        /* Try reloading anyway */
        window.location.reload();
      };
      req.onblocked = function() {
        console.warn('IndexedDB delete blocked â€” reloading');
        window.location.reload();
      };
    });

    /* ------------------------------------------------------------------ */
    /*  Emscripten Module configuration                                   */
    /* ------------------------------------------------------------------ */
    diagLog('Running pre-flight checks...');
    var preflightOk = runPreflightChecks();

    var _engineErrors = [];
    var Module = {
      canvas: canvasEl,
      noInitialRun: true,
      print: function(text) { console.log(text); },
      printErr: function(text) {
        console.error(text);
        _engineErrors.push(text);
        /* Keep last 50 engine errors for diagnostics */
        if (_engineErrors.length > 50) _engineErrors.shift();
      },
      setStatus: function(text) {
        if (text) {
          statusEl.textContent = text;
          diagLog('Engine status: ' + text);
        }
        else statusEl.style.display = 'none';
      },
      onRuntimeInitialized: function() {
        if (preflightOk) {
          onEngineReady();
        }
      },
      onAbort: function(what) {
        diagLog('Emscripten aborted: ' + what, 'fail');
        showError(
          'ENGINE ABORTED',
          'The WebAssembly engine aborted unexpectedly.',
          String(what) + '\n\nRecent engine errors:\n' + _engineErrors.slice(-10).join('\n')
        );
      },
    };
    diagLog('Loading openxcom.js...');
  </script>
  <script async src="openxcom.js"></script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(function(err) {
        console.warn('SW registration failed:', err);
      });
    }
  </script>
</body>
</html>
