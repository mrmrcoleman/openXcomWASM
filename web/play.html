<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>OpenXcom</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; background: #000; overflow: hidden; font-family: sans-serif; }

    /* ---- Game canvas (hidden until the game starts) ---- */
    #canvas {
      display: none;
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      cursor: none;
    }

    /* ---- Status bar ---- */
    #status {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: #0f0;
      font-family: monospace;
      font-size: 14px;
      z-index: 10;
    }

    /* ---- Upload screen ---- */
    #upload-screen {
      display: none;
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: #111;
      color: #ccc;
      z-index: 20;
      overflow-y: auto;
    }
    #upload-screen .inner {
      max-width: 640px;
      margin: 60px auto;
      padding: 0 20px;
    }
    #upload-screen h1 {
      color: #0f0;
      font-family: monospace;
      font-size: 28px;
      margin-bottom: 8px;
    }
    #upload-screen h2 {
      color: #0a0;
      font-family: monospace;
      font-size: 16px;
      font-weight: normal;
      margin-bottom: 24px;
    }
    #upload-screen p {
      line-height: 1.6;
      margin-bottom: 16px;
      font-size: 15px;
    }
    #upload-screen .note {
      color: #888;
      font-size: 13px;
    }
    #drop-zone {
      border: 2px dashed #444;
      border-radius: 12px;
      padding: 40px 20px;
      text-align: center;
      margin: 24px 0;
      transition: border-color 0.2s, background 0.2s;
      cursor: pointer;
    }
    #drop-zone.drag-over {
      border-color: #0f0;
      background: rgba(0,255,0,0.05);
    }
    #drop-zone .icon { font-size: 48px; margin-bottom: 12px; }
    #drop-zone .label { font-size: 16px; color: #aaa; }
    #drop-zone .sublabel { font-size: 13px; color: #666; margin-top: 8px; }
    #file-input { display: none; }
    #upload-btn {
      display: none;
      margin: 16px auto;
      padding: 12px 32px;
      background: #0a0;
      color: #000;
      font-size: 16px;
      font-weight: bold;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    #upload-btn:hover { background: #0c0; }
    #file-list {
      margin: 12px 0;
      font-family: monospace;
      font-size: 13px;
      color: #888;
      max-height: 160px;
      overflow-y: auto;
    }
    #upload-progress {
      display: none;
      margin: 16px 0;
      font-family: monospace;
      color: #0f0;
    }

    /* ---- Toolbar (visible during gameplay) ---- */
    #toolbar {
      display: none;
      position: fixed;
      top: 8px; right: 8px;
      z-index: 30;
    }
    #toolbar-toggle {
      width: 36px; height: 36px;
      background: rgba(30,30,30,0.8);
      border: 1px solid #444;
      border-radius: 6px;
      color: #aaa;
      font-size: 20px;
      cursor: pointer;
      line-height: 34px;
      text-align: center;
    }
    #toolbar-toggle:hover { background: rgba(60,60,60,0.9); color: #fff; }
    #toolbar-menu {
      display: none;
      margin-top: 4px;
      background: rgba(20,20,20,0.95);
      border: 1px solid #444;
      border-radius: 8px;
      padding: 6px 0;
      min-width: 180px;
    }
    #toolbar-menu button {
      display: block;
      width: 100%;
      padding: 8px 16px;
      background: none;
      border: none;
      color: #ccc;
      font-size: 14px;
      text-align: left;
      cursor: pointer;
      font-family: sans-serif;
    }
    #toolbar-menu button:hover { background: rgba(255,255,255,0.1); color: #fff; }
    #toolbar-menu .danger { color: #f55; }
    #toolbar-menu .danger:hover { background: rgba(255,50,50,0.15); }
    #toolbar-menu .sep { height: 1px; background: #333; margin: 4px 0; }

    /* ---- Modal overlay for import/confirm ---- */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 40;
      justify-content: center;
      align-items: center;
    }
    .modal-overlay.active { display: flex; }
    .modal-box {
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 10px;
      padding: 24px 28px;
      max-width: 420px;
      width: 90%;
      color: #ccc;
    }
    .modal-box h3 { color: #fff; margin-bottom: 12px; font-size: 18px; }
    .modal-box p { margin-bottom: 16px; line-height: 1.5; font-size: 14px; }
    .modal-box .btn-row { display: flex; gap: 10px; justify-content: flex-end; }
    .modal-box button {
      padding: 8px 20px;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
    }
    .modal-box .btn-cancel { background: #333; color: #ccc; }
    .modal-box .btn-cancel:hover { background: #444; }
    .modal-box .btn-confirm { background: #0a0; color: #000; font-weight: bold; }
    .modal-box .btn-confirm:hover { background: #0c0; }
    .modal-box .btn-danger { background: #c22; color: #fff; font-weight: bold; }
    .modal-box .btn-danger:hover { background: #e33; }
    .modal-box .modal-status {
      font-family: monospace;
      font-size: 13px;
      color: #0f0;
      margin-top: 12px;
    }
    #import-file-input { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
  <div id="status">Loading engine...</div>

  <!-- Upload screen shown when UFO data is not yet in IndexedDB -->
  <div id="upload-screen">
    <div class="inner">
      <h1>OpenXcom</h1>
      <h2>Browser Edition</h2>
      <p>
        OpenXcom requires the original X-COM: UFO Defense game data to play.
        Upload your <strong>UFO/</strong> data folder below. The files will be
        stored in your browser and persist across sessions.
      </p>
      <p class="note">
        On Steam, the data is typically at:<br>
        <code>steamapps/common/XCom UFO Defense/XCOM/</code><br>
        You need the folders: GEODATA, GEOGRAPH, MAPS, ROUTES, SOUND, TERRAIN, UFOGRAPH, UNITS
      </p>

      <div id="drop-zone">
        <div class="icon">&#128193;</div>
        <div class="label">Drop your UFO data folder here</div>
        <div class="sublabel">or click to browse</div>
      </div>
      <input type="file" id="file-input" webkitdirectory multiple>
      <div id="file-list"></div>
      <button id="upload-btn">Install Game Data</button>
      <div id="upload-progress"></div>

      <!-- Optional: restore saves alongside game data -->
      <div id="restore-saves-section" style="margin-top: 32px; padding-top: 24px; border-top: 1px solid #333;">
        <p style="color: #aaa; font-size: 14px; margin-bottom: 12px;">
          <strong style="color: #ccc;">Have a save backup?</strong>
          If you previously exported your saves, you can restore them here
          before starting the game.
        </p>
        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
          <button id="restore-saves-btn" style="padding: 8px 20px; background: #333; color: #ccc; border: 1px solid #555; border-radius: 5px; cursor: pointer; font-size: 14px;">Import Saves (.zip or .sav)</button>
          <span id="restore-saves-status" style="font-family: monospace; font-size: 13px; color: #0f0;"></span>
        </div>
        <input type="file" id="restore-saves-input" multiple style="display:none;">
      </div>
    </div>
  </div>

  <!-- Toolbar (visible during gameplay) -->
  <div id="toolbar">
    <div id="toolbar-toggle">&#9881;</div>
    <div id="toolbar-menu">
      <button id="btn-export">&#128190; Export Saves</button>
      <button id="btn-import">&#128194; Import Saves</button>
      <div class="sep"></div>
      <button id="btn-reset" class="danger">&#128465; Reset All Data</button>
    </div>
  </div>

  <!-- Import modal -->
  <div class="modal-overlay" id="import-modal">
    <div class="modal-box">
      <h3>Import Saves</h3>
      <p>Upload a <strong>.zip</strong> file containing your exported saves,
         or individual <strong>.sav</strong> files. Existing saves with the
         same name will be overwritten.</p>
      <div class="btn-row">
        <button class="btn-cancel" id="import-cancel">Cancel</button>
        <button class="btn-confirm" id="import-choose">Choose File(s)</button>
      </div>
      <input type="file" id="import-file-input" multiple>
      <div class="modal-status" id="import-status"></div>
    </div>
  </div>

  <!-- Reset confirm modal -->
  <div class="modal-overlay" id="reset-modal">
    <div class="modal-box">
      <h3>Reset All Data</h3>
      <p>This will <strong>permanently delete</strong> all uploaded game data
         and saved games from your browser. You will need to upload the UFO
         data again.</p>
      <div class="btn-row">
        <button class="btn-cancel" id="reset-cancel">Cancel</button>
        <button class="btn-danger" id="reset-confirm">Delete Everything</button>
      </div>
    </div>
  </div>

  <!-- JSZip for save export/import -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <script>
    /* ------------------------------------------------------------------ */
    /*  Globals                                                           */
    /* ------------------------------------------------------------------ */
    var statusEl        = document.getElementById('status');
    var canvasEl        = document.getElementById('canvas');
    var uploadScreen    = document.getElementById('upload-screen');
    var dropZone        = document.getElementById('drop-zone');
    var fileInput       = document.getElementById('file-input');
    var fileListEl      = document.getElementById('file-list');
    var uploadBtn       = document.getElementById('upload-btn');
    var uploadProgress  = document.getElementById('upload-progress');

    var PERSIST_DIR     = '/home/web_user/.local/share/openxcom';
    var UFO_DIR         = PERSIST_DIR + '/UFO';
    var REQUIRED_DIRS   = ['GEODATA','GEOGRAPH','MAPS','ROUTES','SOUND','TERRAIN','UFOGRAPH','UNITS'];

    /* Files selected by the user (array of {path, file} objects) */
    var pendingFiles = [];

    /* ------------------------------------------------------------------ */
    /*  Canvas scaling                                                    */
    /* ------------------------------------------------------------------ */
    function fitCanvas() {
      var cw = canvasEl.width, ch = canvasEl.height;
      if (!cw || !ch) return;
      var ratio = cw / ch;
      var winW = window.innerWidth, winH = window.innerHeight;
      var w, h;
      if (winW / winH > ratio) { h = winH; w = Math.round(h * ratio); }
      else                     { w = winW; h = Math.round(w / ratio); }
      canvasEl.style.width  = w + 'px';
      canvasEl.style.height = h + 'px';
    }
    window.addEventListener('resize', fitCanvas);
    canvasEl.addEventListener('click', function() { canvasEl.focus(); });

    /* ------------------------------------------------------------------ */
    /*  IDBFS helpers                                                     */
    /* ------------------------------------------------------------------ */
    function mkdirp(path) {
      var parts = path.split('/').filter(Boolean);
      var cur = '';
      for (var i = 0; i < parts.length; i++) {
        cur += '/' + parts[i];
        try { Module.FS.mkdir(cur); } catch(e) { /* already exists */ }
      }
    }

    function syncFromIDB(cb) {
      Module.FS.syncfs(true, function(err) {
        if (err) console.error('syncfs(populate) error:', err);
        cb(err);
      });
    }

    function syncToIDB(cb) {
      Module.FS.syncfs(false, function(err) {
        if (err) console.error('syncfs(persist) error:', err);
        if (cb) cb(err);
      });
    }

    /** Check whether REQUIRED_DIRS exist under UFO_DIR */
    function hasUFOData() {
      try {
        var entries = Module.FS.readdir(UFO_DIR);
        var upper = entries.map(function(e) { return e.toUpperCase(); });
        for (var i = 0; i < REQUIRED_DIRS.length; i++) {
          if (upper.indexOf(REQUIRED_DIRS[i]) === -1) return false;
        }
        return true;
      } catch(e) {
        return false;
      }
    }

    /* ------------------------------------------------------------------ */
    /*  Upload screen logic                                               */
    /* ------------------------------------------------------------------ */
    dropZone.addEventListener('click', function() { fileInput.click(); });

    dropZone.addEventListener('dragover', function(e) {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.add('drag-over');
    });
    dropZone.addEventListener('dragleave', function(e) {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.remove('drag-over');
    });
    dropZone.addEventListener('drop', function(e) {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.remove('drag-over');
      handleDroppedItems(e.dataTransfer.items);
    });

    fileInput.addEventListener('change', function() {
      handleSelectedFiles(fileInput.files);
    });

    /** Process files from the directory picker (<input webkitdirectory>) */
    function handleSelectedFiles(fileList) {
      pendingFiles = [];
      for (var i = 0; i < fileList.length; i++) {
        var f = fileList[i];
        /* webkitRelativePath gives e.g. "UFO/GEODATA/foo.dat" */
        var rel = f.webkitRelativePath || f.name;
        /* Strip the top-level directory name so we get "GEODATA/foo.dat" */
        var parts = rel.split('/');
        if (parts.length > 1) parts.shift();
        var path = parts.join('/');
        pendingFiles.push({ path: path, file: f });
      }
      showPendingFiles();
    }

    /** Process items from drag-and-drop (supports directory entries) */
    function handleDroppedItems(items) {
      pendingFiles = [];
      var promises = [];
      for (var i = 0; i < items.length; i++) {
        var entry = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
        if (entry) {
          promises.push(readEntryRecursive(entry, ''));
        }
      }
      Promise.all(promises).then(function() { showPendingFiles(); });
    }

    function readEntryRecursive(entry, basePath) {
      return new Promise(function(resolve) {
        if (entry.isFile) {
          entry.file(function(f) {
            var path = basePath ? basePath + '/' + f.name : f.name;
            pendingFiles.push({ path: path, file: f });
            resolve();
          });
        } else if (entry.isDirectory) {
          var reader = entry.createReader();
          reader.readEntries(function(entries) {
            var sub = basePath ? basePath + '/' + entry.name : entry.name;
            /* If this is the top-level dropped folder, skip its name */
            if (!basePath) sub = '';
            var ps = [];
            for (var i = 0; i < entries.length; i++) {
              ps.push(readEntryRecursive(entries[i], sub || entries[i].name.split('/')[0] ? sub : ''));
            }
            /* Actually, we want to include the entry names properly */
            ps = [];
            for (var i = 0; i < entries.length; i++) {
              var childBase = basePath ? basePath + '/' + entry.name : entry.name;
              /* If top-level drop, strip the folder name */
              if (!basePath) childBase = '';
              ps.push(readEntryRecursive(entries[i], childBase));
            }
            Promise.all(ps).then(resolve);
          });
        } else {
          resolve();
        }
      });
    }

    function showPendingFiles() {
      if (pendingFiles.length === 0) return;
      /* Show a summary */
      var dirs = {};
      pendingFiles.forEach(function(f) {
        var d = f.path.split('/')[0].toUpperCase();
        dirs[d] = (dirs[d] || 0) + 1;
      });
      var summary = Object.keys(dirs).sort().map(function(d) {
        return d + '/ (' + dirs[d] + ' files)';
      }).join('<br>');
      fileListEl.innerHTML = '<strong>' + pendingFiles.length + ' files found:</strong><br>' + summary;
      uploadBtn.style.display = 'block';
    }

    /** Write pending files into the Emscripten VFS and persist to IndexedDB */
    uploadBtn.addEventListener('click', function() {
      uploadBtn.style.display = 'none';
      uploadProgress.style.display = 'block';
      uploadProgress.textContent = 'Installing game data...';

      var done = 0;
      var total = pendingFiles.length;

      function writeNext() {
        if (done >= total) {
          uploadProgress.textContent = 'Saving to browser storage...';
          syncToIDB(function() {
            uploadProgress.textContent = 'Done!';
            setTimeout(startGame, 500);
          });
          return;
        }
        var item = pendingFiles[done];
        var reader = new FileReader();
        reader.onload = function() {
          var fullPath = UFO_DIR + '/' + item.path;
          /* Ensure parent directories exist */
          var dirParts = fullPath.split('/');
          dirParts.pop(); /* remove filename */
          mkdirp(dirParts.join('/'));
          Module.FS.writeFile(fullPath, new Uint8Array(reader.result));
          done++;
          if (done % 20 === 0 || done === total) {
            uploadProgress.textContent = 'Installing... ' + done + '/' + total;
          }
          /* Yield to the browser periodically */
          if (done % 50 === 0) setTimeout(writeNext, 0);
          else writeNext();
        };
        reader.readAsArrayBuffer(item.file);
      }
      writeNext();
    });

    /* ------------------------------------------------------------------ */
    /*  Restore saves on upload screen                                    */
    /* ------------------------------------------------------------------ */
    var restoreBtn    = document.getElementById('restore-saves-btn');
    var restoreInput  = document.getElementById('restore-saves-input');
    var restoreStatus = document.getElementById('restore-saves-status');

    restoreBtn.addEventListener('click', function() { restoreInput.click(); });

    restoreInput.addEventListener('change', function() {
      var files = restoreInput.files;
      if (!files || files.length === 0) return;

      var firstFile = files[0];
      var isZip = firstFile.name.toLowerCase().endsWith('.zip');

      if (isZip) {
        restoreFromZip(firstFile);
      } else {
        restoreLooseFiles(files);
      }
    });

    function restoreFromZip(file) {
      restoreStatus.textContent = 'Reading zip...';
      var reader = new FileReader();
      reader.onload = function() {
        JSZip.loadAsync(reader.result).then(function(zip) {
          var entries = [];
          zip.forEach(function(relativePath, zipEntry) {
            if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.sav'))
              entries.push(zipEntry);
          });
          if (entries.length === 0) {
            restoreStatus.textContent = 'No .sav files found in the zip.';
            restoreInput.value = '';
            return;
          }
          restoreStatus.textContent = 'Restoring ' + entries.length + ' save(s)...';
          var done = 0;
          function next() {
            if (done >= entries.length) {
              restoreStatus.textContent = entries.length + ' save(s) queued for import.';
              restoreInput.value = '';
              /* Store for writing after IDBFS is mounted */
              window._pendingRestoreSaves = entries.map(function(e) { return e; });
              /* Actually write them now if FS is ready */
              writePendingRestores();
              return;
            }
            entries[done].async('uint8array').then(function(data) {
              entries[done]._data = data;
              done++;
              next();
            });
          }
          next();
        }).catch(function(err) {
          restoreStatus.textContent = 'Error reading zip: ' + err;
        });
      };
      reader.readAsArrayBuffer(file);
    }

    function restoreLooseFiles(fileList) {
      var savFiles = [];
      for (var i = 0; i < fileList.length; i++) {
        if (fileList[i].name.toLowerCase().endsWith('.sav'))
          savFiles.push(fileList[i]);
      }
      if (savFiles.length === 0) {
        restoreStatus.textContent = 'No .sav files found.';
        restoreInput.value = '';
        return;
      }
      restoreStatus.textContent = 'Reading ' + savFiles.length + ' file(s)...';
      window._pendingRestoreLoose = [];
      var done = 0;
      function readNext() {
        if (done >= savFiles.length) {
          restoreStatus.textContent = savFiles.length + ' save(s) queued for import.';
          restoreInput.value = '';
          writePendingRestores();
          return;
        }
        var f = savFiles[done];
        var reader = new FileReader();
        reader.onload = function() {
          window._pendingRestoreLoose.push({ name: f.name, data: new Uint8Array(reader.result) });
          done++;
          readNext();
        };
        reader.readAsArrayBuffer(f);
      }
      readNext();
    }

    /** Write pending restore saves into the VFS (only works after IDBFS mount) */
    function writePendingRestores() {
      /* If the FS isn't mounted yet, saves will be written in startGame */
      if (!window._idbfsMounted) return;

      var savesDir = PERSIST_DIR + '/xcom1';
      mkdirp(savesDir);

      /* From zip */
      if (window._pendingRestoreSaves) {
        window._pendingRestoreSaves.forEach(function(entry) {
          if (entry._data) {
            var fullPath = PERSIST_DIR + '/' + entry.name;
            var dirParts = fullPath.split('/'); dirParts.pop();
            mkdirp(dirParts.join('/'));
            Module.FS.writeFile(fullPath, entry._data);
          }
        });
        delete window._pendingRestoreSaves;
      }

      /* From loose files */
      if (window._pendingRestoreLoose) {
        window._pendingRestoreLoose.forEach(function(item) {
          Module.FS.writeFile(savesDir + '/' + item.name, item.data);
        });
        delete window._pendingRestoreLoose;
      }

      syncToIDB(function() {
        restoreStatus.textContent = 'Saves restored successfully!';
      });
    }

    /* ------------------------------------------------------------------ */
    /*  Game startup orchestration                                        */
    /* ------------------------------------------------------------------ */
    function showUploadScreen() {
      uploadScreen.style.display = 'block';
      statusEl.style.display = 'none';
    }

    function startGame() {
      uploadScreen.style.display = 'none';
      canvasEl.style.display = 'block';
      toolbar.style.display = 'block';
      statusEl.textContent = 'Starting OpenXcom...';
      statusEl.style.display = 'block';

      /* Launch main() — we set INVOKE_RUN=0 so it hasn't started yet */
      Module.callMain();

      statusEl.textContent = 'Running...';
      setTimeout(function() { statusEl.style.display = 'none'; }, 2000);
      setTimeout(fitCanvas, 200);
      setTimeout(fitCanvas, 1000);
    }

    /**
     * Called once the Emscripten runtime is ready.
     * Sets up IDBFS, checks for existing game data, and either starts
     * the game or shows the upload screen.
     */
    function onEngineReady() {
      statusEl.textContent = 'Checking for game data...';

      /* Create the persistent directory tree and mount IDBFS */
      mkdirp(PERSIST_DIR);
      Module.FS.mount(Module.FS.filesystems.IDBFS, {}, PERSIST_DIR);

      /* Populate the VFS from IndexedDB */
      syncFromIDB(function() {
        window._idbfsMounted = true;

        /* Write any saves that were queued on the upload screen */
        if (window._pendingRestoreSaves || window._pendingRestoreLoose) {
          writePendingRestores();
        }

        if (hasUFOData()) {
          console.log('UFO data found in IndexedDB — starting game');
          startGame();
        } else {
          console.log('No UFO data found — showing upload screen');
          showUploadScreen();
        }
      });
    }

    /* ------------------------------------------------------------------ */
    /*  Toolbar: export, import, reset                                    */
    /* ------------------------------------------------------------------ */
    var toolbar      = document.getElementById('toolbar');
    var toolbarMenu  = document.getElementById('toolbar-menu');
    var toolbarToggle = document.getElementById('toolbar-toggle');

    toolbarToggle.addEventListener('click', function(e) {
      e.stopPropagation();
      toolbarMenu.style.display = toolbarMenu.style.display === 'block' ? 'none' : 'block';
    });
    document.addEventListener('click', function() { toolbarMenu.style.display = 'none'; });

    /* ---- Export saves ---- */
    document.getElementById('btn-export').addEventListener('click', function() {
      toolbarMenu.style.display = 'none';
      exportSaves();
    });

    function collectFiles(dir, base) {
      var result = [];
      try {
        var entries = Module.FS.readdir(dir);
      } catch(e) { return result; }
      for (var i = 0; i < entries.length; i++) {
        if (entries[i] === '.' || entries[i] === '..') continue;
        var full = dir + '/' + entries[i];
        var rel  = base ? base + '/' + entries[i] : entries[i];
        var stat;
        try { stat = Module.FS.stat(full); } catch(e) { continue; }
        if (Module.FS.isDir(stat.mode)) {
          result = result.concat(collectFiles(full, rel));
        } else {
          result.push({ path: rel, fullPath: full });
        }
      }
      return result;
    }

    function exportSaves() {
      /* First sync to make sure IDBFS is up to date */
      syncToIDB(function() {
        var savesDir = PERSIST_DIR + '/xcom1';
        var files = collectFiles(savesDir, 'xcom1');

        /* Also grab options.cfg if it exists */
        try {
          Module.FS.stat(PERSIST_DIR + '/options.cfg');
          files.push({ path: 'options.cfg', fullPath: PERSIST_DIR + '/options.cfg' });
        } catch(e) {}

        if (files.length === 0) {
          alert('No save data found to export.');
          return;
        }

        var zip = new JSZip();
        for (var i = 0; i < files.length; i++) {
          try {
            var data = Module.FS.readFile(files[i].fullPath);
            zip.file(files[i].path, data);
          } catch(e) {
            console.warn('Could not read ' + files[i].fullPath, e);
          }
        }

        zip.generateAsync({ type: 'blob' }).then(function(blob) {
          var a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          var d = new Date();
          a.download = 'openxcom-saves-' + d.toISOString().slice(0,10) + '.zip';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(a.href);
        });
      });
    }

    /* ---- Import saves ---- */
    var importModal     = document.getElementById('import-modal');
    var importFileInput = document.getElementById('import-file-input');
    var importStatus    = document.getElementById('import-status');

    document.getElementById('btn-import').addEventListener('click', function() {
      toolbarMenu.style.display = 'none';
      importStatus.textContent = '';
      importModal.classList.add('active');
    });
    document.getElementById('import-cancel').addEventListener('click', function() {
      importModal.classList.remove('active');
    });
    document.getElementById('import-choose').addEventListener('click', function() {
      importFileInput.click();
    });

    importFileInput.addEventListener('change', function() {
      var files = importFileInput.files;
      if (!files || files.length === 0) return;

      /* Check if the first file is a zip */
      var firstFile = files[0];
      var isZip = firstFile.name.toLowerCase().endsWith('.zip');

      if (isZip) {
        importFromZip(firstFile);
      } else {
        importLooseFiles(files);
      }
    });

    function importFromZip(file) {
      importStatus.textContent = 'Reading zip...';
      var reader = new FileReader();
      reader.onload = function() {
        JSZip.loadAsync(reader.result).then(function(zip) {
          var entries = [];
          zip.forEach(function(relativePath, zipEntry) {
            if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.sav'))
              entries.push(zipEntry);
          });
          if (entries.length === 0) {
            importStatus.textContent = 'No .sav files found in the zip.';
            importFileInput.value = '';
            return;
          }
          importStatus.textContent = 'Importing ' + entries.length + ' save(s)...';

          var done = 0;
          function nextEntry() {
            if (done >= entries.length) {
              finishImport(entries.length);
              return;
            }
            var entry = entries[done];
            entry.async('uint8array').then(function(data) {
              var fullPath = PERSIST_DIR + '/' + entry.name;
              var dirParts = fullPath.split('/');
              dirParts.pop();
              mkdirp(dirParts.join('/'));
              Module.FS.writeFile(fullPath, data);
              done++;
              if (done % 10 === 0) importStatus.textContent = 'Importing... ' + done + '/' + entries.length;
              if (done % 50 === 0) setTimeout(nextEntry, 0);
              else nextEntry();
            });
          }
          nextEntry();
        }).catch(function(err) {
          importStatus.textContent = 'Error reading zip: ' + err;
        });
      };
      reader.readAsArrayBuffer(file);
    }

    /** Import individual .sav files directly into xcom1/ */
    function importLooseFiles(fileList) {
      /* Filter to only .sav files */
      var savFiles = [];
      for (var i = 0; i < fileList.length; i++) {
        if (fileList[i].name.toLowerCase().endsWith('.sav'))
          savFiles.push(fileList[i]);
      }
      if (savFiles.length === 0) {
        importStatus.textContent = 'No .sav files found. Please select OpenXcom save files (.sav).';
        importFileInput.value = '';
        return;
      }

      var savesDir = PERSIST_DIR + '/xcom1';
      mkdirp(savesDir);
      importStatus.textContent = 'Importing ' + savFiles.length + ' save(s)...';
      var done = 0;
      var total = savFiles.length;

      function readNext() {
        if (done >= total) {
          finishImport(total);
          return;
        }
        var f = savFiles[done];
        var reader = new FileReader();
        reader.onload = function() {
          var fullPath = savesDir + '/' + f.name;
          Module.FS.writeFile(fullPath, new Uint8Array(reader.result));
          done++;
          importStatus.textContent = 'Importing... ' + done + '/' + total;
          if (done % 20 === 0) setTimeout(readNext, 0);
          else readNext();
        };
        reader.readAsArrayBuffer(f);
      }
      readNext();
    }

    function finishImport(count) {
      importStatus.textContent = 'Saving to browser storage...';
      syncToIDB(function() {
        importStatus.textContent = 'Import complete! (' + count + ' file' + (count !== 1 ? 's' : '') + ')';
        importFileInput.value = '';
        setTimeout(function() { importModal.classList.remove('active'); }, 1500);
      });
    }

    /* ---- Reset all data ---- */
    var resetModal = document.getElementById('reset-modal');

    document.getElementById('btn-reset').addEventListener('click', function() {
      toolbarMenu.style.display = 'none';
      resetModal.classList.add('active');
    });
    document.getElementById('reset-cancel').addEventListener('click', function() {
      resetModal.classList.remove('active');
    });
    document.getElementById('reset-confirm').addEventListener('click', function() {
      resetModal.classList.remove('active');
      statusEl.textContent = 'Deleting all data...';
      statusEl.style.display = 'block';

      /* Delete all entries from the IndexedDB database directly */
      var dbName = PERSIST_DIR;
      var req = indexedDB.deleteDatabase(dbName);
      req.onsuccess = function() {
        console.log('IndexedDB deleted:', dbName);
        window.location.reload();
      };
      req.onerror = function() {
        console.error('Failed to delete IndexedDB:', dbName);
        /* Try reloading anyway */
        window.location.reload();
      };
      req.onblocked = function() {
        console.warn('IndexedDB delete blocked — reloading');
        window.location.reload();
      };
    });

    /* ------------------------------------------------------------------ */
    /*  Emscripten Module configuration                                   */
    /* ------------------------------------------------------------------ */
    var Module = {
      canvas: canvasEl,
      noInitialRun: true,        /* we call callMain() ourselves */
      print: function(text) { console.log(text); },
      printErr: function(text) { console.error(text); },
      setStatus: function(text) {
        if (text) statusEl.textContent = text;
        else statusEl.style.display = 'none';
      },
      onRuntimeInitialized: function() {
        onEngineReady();
      },
    };
  </script>
  <script async src="openxcom.js"></script>
</body>
</html>
